ebin_dir = .

# This is a directory where application specific .hrl
# files can be placed. Application-specific .yaws code can
# then include these .hrl files.
#include_dir = /usr/lib/yaws/examples/include

# This is a debug variable, possible values are http | traffic | false
# It is also possible to set the trace (possibly to the tty) while
# invoking yaws from the shell as in
# yaws -i -T -x (see man yaws).
trace = false

# It is possible to have yaws start additional application-specific code at
# startup. Set runmod to the name of the module you want yaws to start. It
# assumes the module has an exported function start/0. To have multiple
# runmods just add more "runmod = xyz" lines.
#
# runmod = mymodule

# Fail completely or not if yaws fails to bind a listen socket.
fail_on_bind_err = true

# When we're running multiple yaws systems on the same
# host, we need to give each yaws system an individual
# name. Yaws will write a number of runtime files under
# ${HOME}/.yaws/yaws/${id}
# The default value is "default"
# If we're not planning to run multiple webservers on the
# same host it's much better to leave this value unset since
# then all the ctl function (--stop et.el) work without having
# to supply the id.
#
# id = myname

# Earlier versions of Yaws picked the first virtual host
# in a list of hosts with the same IP/PORT when the Host:
# header doesn't match any name on any Host.
# This is often nice in testing environments but not
# acceptable in real-world hosting scenarios;
# think http://porn.bigcompany.com
pick_first_virthost_on_nomatch = true

# If the HTTP client session is to be kept alive, wait this many
# milliseconds for a new request before timing out the connection. Note
# that infinity is a valid value but it's not recommended.
keepalive_timeout = 30000

<server deals_yaws>
        port = 3000
        listen = 0.0.0.0
        docroot = ./public
        auth_log = true
        appmods = <cgi-bin, yaws_appmod_cgi>
</server>

